--Kyle 'Avoca' Abent

--Anti Exploit--------------------------------------

/*
Spawning cysts nearby front doors when theyre closed == kill
Spawning something inside siege when its closed and having it build == kill
same with teleporting :P


prevent macs/arcs from going through doors.. and add timer when they're created to make sure robo wasnt exploited either
*/



--local arcorig = ARC.OnOrderComplete
function ARC:OnOrderComplete(currentOrder)
--if arcorig ~= nil then arcorig(currentOrder) end


    
 if Server then    
 
   --:UpdateMoveOrder(deltaTime)  if self:GetCurrentOrder() == nil then set mode.
    -- Whereas imaginator spams orders never setting  back to station
   if currentOrder:GetType()== kTechId.Move then
            self:SetMode(ARC.kMode.Stationary)
    end
    
          -- Print("Arc order complete 1")
        --  local imagination = GetImaginator()
       -- if imagination~= nil and imagination:GetMarineEnabled() and currentOrder:GetType() == kTechId.Move then
      --  Print("Arc order complete 2")
        self:CheckArc()
      --  self:AddTimedCallback(function()  self:SetMode(ARC.kMode.Stationary) self:GiveOrder(kTechId.ARCDeploy, self:GetId(), self:GetOrigin(), nil, true, true) return false end, 1) 
         
       --  end
         
 ExploitCheck(self) 
      end
    
end

--local macorig = MAC.OnOrderComplete
function MAC:OnOrderComplete(currentOrder)
--if macorig ~= nil then macorig(currentOrder) end

      if self.rolloutSourceFactory then

        self.rolloutSourceFactory:CompleteRollout(self)
        self.rolloutSourceFactory = nil

    end
    
if Server then  ExploitCheck(self) end 
end


if Server then
local locorig = Location.OnTriggerExited
function Location:OnTriggerExited(entity, triggerEnt)
if not entity:isa("Player") then return end
locorig(self,entity, triggerEnt)
ExploitCheck(entity)
end

end--server
/*
local function CommPoint(self, value)

       local commander = self:GetTeam():GetCommander()
       if commander ~= nil then
       commander:AddScore(value) 
       end
       
end

local recorig = RecycleMixin.OnRecycled
function RecycleMixin:OnRecycled()
recorig(self)
if self:GetIsBuilt() then CommPoint(self, -1) end
end
*/
local constorig = ConstructMixin.OnConstructionComplete
function ConstructMixin:OnConstructionComplete(builder)
  constorig(self, builder)
  if Server then ExploitCheck(self) end --CommPoint(self, 1) end
end    

local clogorig = Clog.OnInitialized

function Clog:OnInitialized()
  clogorig(self)
  if Server then ExploitCheck(self) end
end    


local cystorig = Cyst.OnInitialized

function Cyst:OnInitialized()
  cystorig(self)
  if Server then ExploitCheck(self) end
end    

local drifterorig = Drifter.OnInitialized
function Drifter:OnInitialized()
  drifterorig(self)
  if Server then ExploitCheck(self) end
end    

local eggorig = Egg.OnInitialized

function Egg:OnInitialized()
  eggorig(self)
  if Server then ExploitCheck(self) end
end    

local tunnelorig = TunnelEntrance.OnInitialized
function TunnelEntrance:OnInitialized()
  tunnelorig(self)
  if Server then ExploitCheck(self) end
end    

local contorig = Contamination.OnInitialized

function Contamination:OnInitialized()
  contorig(self)
  if Server then ExploitCheck(self) end
end    

local function OnRolloutTimeout(self)
 if Server then ExploitCheck(self) end
    return false
end

local rollorig =  RolloutMixin.Rollout
function RolloutMixin:Rollout(factory, factoryRolloutLength)
  rollorig(self, factory, factoryRolloutLength)
   self:AddTimedCallback(OnRolloutTimeout, 12)
end    


--lazy
function PathingMixin:CheckTarget(endPoint)

    // if we don't have a cursor, or the targetPoint differs, create a new path
    if self.cursor == nil or (self.targetPoint - endPoint):GetLengthXZ() > 0.1 then
    
        // our current cursor is invalid or pointing to another endpoint, so build a new one
        self.points = GeneratePath(self:GetOrigin(), endPoint, false, 0.5, 2, self:GetIsFlying())
        if self.points == nil then
        
            // Can't reach the endPoint.
            return false
            
        end
        self.targetPoint = endPoint
        // the list of points does not include our current origin. Simplify the remaining code
        // by adding our origin to the list of points
        Pathing.InsertPoint( self.points, 1, self:GetOrigin() )
        
        self.cursor = PathCursor():Init(self.points)
        
    end    
    local trace = Shared.TraceRay(self:GetOrigin(),  endPoint, CollisionRep.Move, PhysicsMask.Movement, EntityFilterAllButIsa("SiegeDoor") )                                                                                                                                                                                                                                                                            
      if trace.entity ~= nil and trace.entity:GetIsLocked() then 
        return false
     end
  
  return true
    
end
/*
---------------------------
Shell, Spur, Veil, and Drifter limits. Why? because without these, alien commanders like to exploit and spawn billions of these.
--------------------------
*/

function GetCheckShellLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Shell")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckVeilLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, veil in ientitylist(Shared.GetEntitiesWithClassname("Veil")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckSpurLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Spur")) do
        
            if not spur:isa("StructureBeacon") then 
                num = num + 1
            end
            
    end
    
    return num < 4
    
end
function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
                num = num + 1
            
    end
    
            for index, derp in ientitylist(Shared.GetEntitiesWithClassname("DrifterEgg")) do
        
                num = num + 1
            
    end
    
    return num < 10
    
end

function GetCheckDropMACLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, mac in ientitylist(Shared.GetEntitiesWithClassname("MAC")) do
             if not mac:isa("MACCredit") then
                num = num + 1
             end
    end
    
    
    return num < 12
    
end


function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 12
    
end
function GetCheckExoSuitLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, exosuit in ientitylist(Shared.GetEntitiesWithClassname("Exosuit")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 8
    
end
function GetCheckJetpackLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, jp in ientitylist(Shared.GetEntitiesWithClassname("Jetpack")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 8
    
end
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit reached for Commander ents of this type")




SetCachedTechData(kTechId.Spur, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")
SetCachedTechData(kTechId.Veil, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")
SetCachedTechData(kTechId.Shell, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")

SetCachedTechData(kTechId.Spur, kTechDataBuildRequiresMethod, GetCheckSpurLimit)
SetCachedTechData(kTechId.Veil, kTechDataBuildRequiresMethod, GetCheckVeilLimit)
SetCachedTechData(kTechId.Shell, kTechDataBuildRequiresMethod, GetCheckShellLimit)

SetCachedTechData(kTechId.Drifter, kTechDataBuildRequiresMethod, GetCheckDrifterLimit)
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")

SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildRequiresMethod, GetCheckDrifterLimit)
SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")

SetCachedTechData(kTechId.DropExosuit, kTechDataBuildRequiresMethod, GetCheckExoSuitLimit)
SetCachedTechData(kTechId.DropExosuit, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")

SetCachedTechData(kTechId.DropJetpack, kTechDataBuildRequiresMethod, GetCheckJetpackLimit)
SetCachedTechData(kTechId.DropJetpack, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")


SetCachedTechData(kTechId.DropMAC, kTechDataBuildRequiresMethod, GetCheckDropMACLimit)
SetCachedTechData(kTechId.DropMAC, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")




---------------------------------------------------------------