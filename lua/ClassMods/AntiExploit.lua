--Kyle 'Avoca' Abent

--Anti Exploit--------------------------------------

/*
Spawning cysts nearby front doors when theyre closed == kill
Spawning something inside siege when its closed and having it build == kill
same with teleporting :P


prevent macs/arcs from going through doors.. and add timer when they're created to make sure robo wasnt exploited either
*/

local constorig = ConstructMixin.OnConstructionComplete

function ConstructMixin:OnConstructionComplete(builder)
  constorig(self, builder)
  if Server then ExploitCheck(self) end
end    

local cystorig = Cyst.OnInitialized

function Cyst:OnInitialized()
  cystorig(self)
  if Server then ExploitCheck(self) end
end    

local tunnelorig = TunnelEntrance.OnInitialized
function TunnelEntrance:OnInitialized()
  tunnelorig(self)
  if Server then ExploitCheck(self) end
end    

local contorig = Contamination.OnInitialized

function Contamination:OnInitialized()
  contorig(self)
  if Server then ExploitCheck(self) end
end    


--Rather than take from teleportmixin... which isnt used..
local repoorig =  RepositioningMixin.OnTeleportEnd
function RepositioningMixin:OnTeleportEnd()
  repoorig(self)
  if Server then ExploitCheck(self) end
end    

local function OnRolloutTimeout(self)
 if Server then ExploitCheck(self) end
    return false
end

local rollorig =  RolloutMixin.Rollout
function RolloutMixin:Rollout(factory, factoryRolloutLength)
  rollorig(self, factory, factoryRolloutLength)
   self:AddTimedCallback(OnRolloutTimeout, 12)
end    


--lazy
function PathingMixin:CheckTarget(endPoint)

    // if we don't have a cursor, or the targetPoint differs, create a new path
    if self.cursor == nil or (self.targetPoint - endPoint):GetLengthXZ() > 0.1 then
    
        // our current cursor is invalid or pointing to another endpoint, so build a new one
        self.points = GeneratePath(self:GetOrigin(), endPoint, false, 0.5, 2, self:GetIsFlying())
        if self.points == nil then
        
            // Can't reach the endPoint.
            return false
            
        end
        self.targetPoint = endPoint
        // the list of points does not include our current origin. Simplify the remaining code
        // by adding our origin to the list of points
        Pathing.InsertPoint( self.points, 1, self:GetOrigin() )
        
        self.cursor = PathCursor():Init(self.points)
        
    end    
    local trace = Shared.TraceRay(self:GetOrigin(),  endPoint, CollisionRep.Move, PhysicsMask.Movement, EntityFilterAllButIsa("SiegeDoor") )                                                                                                                                                                                                                                                                            
      if trace.entity ~= nil and trace.entity:GetIsLocked() then 
        return false
     end
  
  return true
    
end
/*
---------------------------
Shell, Spur, Veil, and Drifter limits. Why? because without these, alien commanders like to exploit and spawn billions of these.
--------------------------
*/

function GetCheckShellLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Shell")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckVeilLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, veil in ientitylist(Shared.GetEntitiesWithClassname("Veil")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckSpurLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Spur")) do
        
            if not spur:isa("StructureBeacon") then 
                num = num + 1
            end
            
    end
    
    return num < 4
    
end
function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
                num = num + 1
            
    end
    
            for index, spur in ientitylist(Shared.GetEntitiesWithClassname("DrifterEgg")) do
        
                num = num + 1
            
    end
    
    return num < 4
    
end



function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit reached for Commander ents of this type")




SetCachedTechData(kTechId.Spur, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")
SetCachedTechData(kTechId.Veil, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")
SetCachedTechData(kTechId.Shell, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")

SetCachedTechData(kTechId.Spur, kTechDataBuildRequiresMethod, GetCheckSpurLimit)
SetCachedTechData(kTechId.Veil, kTechDataBuildRequiresMethod, GetCheckVeilLimit)
SetCachedTechData(kTechId.Shell, kTechDataBuildRequiresMethod, GetCheckShellLimit)

SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildRequiresMethod, GetCheckDrifterLimit)
SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildMethodFailedMessage, "Trying to crash the server?")



---------------------------------------------------------------